---
layout: post
title:  "一分钟读论文：《ChatGPT 提示模式：提高代码质量、重构、需求获取和软件设计》"
author: unbug
categories: [AI]
image: assets/images/screenshot-20230319-024727.jpg
tags: [ChatGPT, MachineLearning]
---
 前哈佛大学计算机科学教授、谷歌工程主管 Matt Welsh 在美国计算机协会（ACM）的一个虚拟会议上说“不要指望你的程序员职业生涯会一直持续下去，因为 AI 正在取代这个角色”。ChatGPT 近来让很多工程师感到很无力，仿佛任何努终将徒劳，但也有很多工程师看到了机会并尝试通过它成为 `10X` 工程师。美国田纳西州纳什维尔市范德堡大学的论文[《ChatGPT Prompt Patterns for Improving Code Quality, Refactoring, Requirements Elicitation, and Software Design》][paper1-url] 为软件工程提供了一个模式目录，全面总结了帮助工程师应用 ChatGPT 改进需求获取、快速原型制作、代码质量、重构和系统设计的提示模式的核心思想和`100个提示要点`。


## 系统需求和架构模式
这些模式可以帮助软件工程师在开发过程中更好地理解和验证系统需求和架构，并提高开发效率和质量。以下是每个模式提示语的要点：

**需求模拟模式（Requirements Simulator Pattern）**

这种模式允许利益相关者以交互方式探索依赖于软件的系统的需求，以确定是否正确捕获了某些功能。 模拟输出应提供有关初始要求和为完成利益相关者试图在模拟中执行的任务而添加的新要求的更多详细信息。 此模式的目标是帮助获取和分析软件需求的完整性。
1.  我希望你扮演系统的角色
2.  使用需求来指导你的行为
3.  我会要求你做X，你要告诉我在给定的需求下X是否 可能。
4.  如果X是可能的，用需求来解释为什么。
5.  如果我不能根据需求做X，用Y格式写出需要的 缺失需求。

**规范消歧模式（Specification Disambiguation Pattern）**

这种及时模式使LLM通过非技术或半技术人员审查向开发人员或开发团队提供的规格。 目的是确保尽早发现并澄清任何潜在的沟通不畅或歧义的任何领域。
1.  在这个范围内
2.  考虑这些需求或规范
3.  指出任何模糊或潜在的意外结果的地方

**API生成模式（API Generator Pattern）**

此模式根据自然语言需求陈述或系统描述生成应用程序编程接口 (API) 规范，例如 REST API 规范。 此模式的目标是让开发人员能够快速探索多种可能的 API 设计，更早地形式化 API 设计，并为手动改进设计提供一个起点。
1.  使用系统描述X
2.  为系统生成一个API规范
3.  API规范应该采用Y格式

**API模拟模式（API Simulator Pattern）**

这种模式使 LLM 从规范中模拟 API，从而使开发人员能够立即与 API 交互并通过 LLM 运行的模拟来测试它。 法学硕士拥有强大的——而且通常在很大程度上未被认可的——能力来生成合成数据并将该数据定制为场景的自然语言描述。 此外，LLM 还可以通过合成示例请求以及提供使用指南和解释错误来帮助开发人员探索模拟 API。
1.  根据规范X扮演描述的系统
2.  我会以Y格式输入请求到API中
3.  你要根据规范X以Z格式响应适当的回应

**少样本代码示例生成模式（Few-shot Code Example Generation Pattern）**

该模式的目标是让 LLM 生成一组使用示例，这些示例稍后可以作为提示中的示例提供回 LLM，以利用少样本学习 [16]。 Few-shot learning 基于在提示中向 LLM 提供一组有限的示例训练数据。 就代码而言，少量示例是 LLM 可以从中学习的代码的正确用法。 在某些情况下，代码示例可以在更大的空间内传达代码的功能和用途。
1.  我将给你提供系统X
2.  创建N个示例来展示使用系统X的方法
3.  尽可能让示例覆盖完整
4.  （可选）示例应该基于系统X的公共接口
5.  （可选）示例应该关注X

**领域特定语言创建模式（DSL Creation Pattern）**

这种模式使 LLM 能够创建自己的领域特定语言 (DSL)，它和用户都可以利用这种语言来描述和操作系统概念，例如需求、部署方面、安全规则或模块方面的体系结构。 然后，LLM 可以为用户设计和描述 DSL。 此外，可以存储 LLM 生成的示例和描述，并在将来提示中使用，以将 DSL 重新引入 LLM。 此外，LLM 生成的示例将作为未来提示的少量示例。
1.  我想让你为X创建一个领域特定语言
2.  语言的语法必须遵循以下约束条件
3.  向我解释这种语言并提供一些例子

**架构可能性模式（Architectural Possibilities Pattern）**

这种模式生成了几种不同的架构供开发人员考虑，而开发人员几乎不需要付出任何努力。 “架构”可以是非常开放的，由开发人员向 LLM 解释这个术语的含义。 开发人员可能希望看到有关如何将代码布局到文件中、如何在模块之间或多层系统中的层之间执行通信的替代体系结构。 该模式的目的是允许开发人员使用 LLM 探索系统的任何这些架构方面。 此外，开发人员可以通过添加更多约束或要求 LLM 根据系统的不同方面（例如文件布局、模块、服务、通信模式、基础设施等）描述架构，以交互方式改进架构建议。
1.  我正在开发一个用X为Y服务的软件系统
2.  系统必须遵守这些约束条件
3.  描述N种可能的架构方案
4.  用Q来描述架构

**变更请求模拟模式（Change Request Simulation Pattern）**

这种模式帮助用户推断所提议的系统变更的复杂性，这可能与需求、体系结构、性能等相关。例如，这种模式帮助用户推断给定的变更可能对系统的某些方面产生什么影响， 例如哪些模块可能需要更改。 当一组利益相关者需要讨论可能的需求变更并且 LLM 可以作为变更范围和影响的（潜在）公正估计器时，这种模式特别有用。
1. 我的软件系统架构是X 
2. 系统必须遵守这些约束条件 
3. 我想让你模拟一个我将描述的对系统的变更 
4. 用Q来描述变更的影响 
5. 这是对我的系统的变更


## 代码质量和重构模式
这些模式可以帮助软件工程师在使用 ChatGPT 生成或修改代码时避免常见的问题和错误，并提高代码的可读性和可维护性。以下是每个模式提示语的要点：

**代码聚类模式（Code Clustering Pattern）**

该模式的目标是根据代码的特定属性将代码分离并聚集成函数、类等，例如分离纯代码和非纯代码、业务逻辑与数据库访问、HTTP 请求处理与业务逻辑。 等等。该模式向LLM定义了预期的集群属性，然后要求LLM自动重构代码以实现所需的集群。 该模式可用于确保 LLM 生成的代码展示集群、重构人工代码以添加集群或审查代码。
1.  在X范围内
2.  我希望你以一种方式编写或重构代码，将具有Y属性的代码与具有Z属性的代码分开。
3.  这些是具有Y属性的代码的例子。
4.  这些是具有Z属性的代码的例子。

**中间抽象模式（Intermediate Abstraction Pattern）**

抽象和模块化是高质量可维护和可重用代码的基本组成部分。 代码的编写方式应将内聚概念隔离到单独的函数或类中，以便可以在范围内隔离编辑。 此外，在使用 LLM 时，如果重构可以隔离到需要修改、替换或添加的单个函数，则重构现有代码会更容易。
1.  如果你编写或重构具有X属性的代码
2.  使用其他具有Y属性的代码
3.  （可选）定义X属性
4.  （可选）定义Y属性
5.  在X和Y之间插入一个中间抽象Z
6.  （可选）抽象Z应该具有这些属性

**原则性代码模式（Principled Code Pattern）**

该模式的目标是使用众所周知的编码原则名称来描述所需的代码结构，而不必明确描述每个单独的设计规则。 例如，一个组织可能希望确保他们的代码遵循 SOLID 设计原则。 目标是快速确保生成、重构和审查的代码符合预期的设计或其他原则。
1.  在这个范围内
2.  生成、重构或创建符合命名原则X的代码

**隐藏假设模式（Hidden Assumptions Pattern）**

此模式的目标是让 LLM 识别和描述在一段代码中所做的任何假设。 该模式帮助用户识别这些假设或提醒他们他们可能已经忘记的假设。 通过向用户展示代码中的关键假设，他们的 LLM 可以帮助确保用户在与代码相关的决策中考虑到这些假设。
1.  在这个范围内
2.  列出这段代码所做的假设
3.  （可选）估计改变这些假设或它们改变的可能性有多难

**伪码重构模式（Pseudo-code Refactoring Pattern）**

此模式的目标是让用户对算法、流程或代码的其他方面进行更细粒度的控制，同时不需要明确指定细节。 该模式允许用户为生成或重构代码的一个或多个细节定义伪代码。 LLM 应调整输出以适应伪代码模板，同时确保代码正确且可运行。
1.  重构这段代码 
2. 使其与这段伪码相匹配 
3. 尽可能地匹配伪码的结构

**数据引导重构模式（Data-guided Refactoring Pattern）** 

此模式的目标是允许用户重构现有代码以使用具有新格式的数据。 用户可以向 LLM 提供新的格式模式并要求 LLM 确定如何进行必要的更改，而不是指定确切的逻辑更改才能使用新格式。 该模式有助于为合并数据格式更改这一常见任务自动进行代码重构
1. 重构这段代码 
2. 使其输入、输出或存储数据格式为X 
3. 提供一个或多个X的例子


![]({{ site.baseurl }}/)

<!--
<p><iframe style="width:100%;" height="315" src="https://arxiv.org/pdf/2112.10165.pdf" frameborder="0" allowfullscreen></iframe></p>


|                                       |                                       |
|:-------------------------------------:|:-------------------------------------:|
|![img1]({{ site.baseurl }}/)| ![img2]({{ site.baseurl }}/) |
-->


## References
- [ACM Chicago Feb 8 2023: Large Language Models and the End of Programming from Matt Welsh of Fixie.ai][links-1]


[paper1-url]: https://arxiv.org/pdf/2303.07839.pdf
[links-1]: https://www.youtube.com/watch?v=qmJ4xLC1ObU